# Лабораторная работа №3

*по курсу: "DEV-OCPJP. Подготовка к сдаче сертификационных экзаменов серии Oracle Certified Professional Java Programmer"*

**Рассматриваемые темы:**

1. Java Stream API:
   - создание потока с использованием метода `generate()`;
   - отбор данных с использованием метода `filter()`;
   - преобразование потоков с использованием метода
   `map()`;
   - сортировка потоков;
   - объединение элементов потока в коллекцию с 
   использованием коллекторов и метода `collect()`.
2. Эталоны проектирования:
   - "Строитель";
   - "Фабрика".
  
## Эталоны проектирования

### Эталон проектирования "Строитель" / Builder

Эталон проектирования "Строитель" используют для создания сложных объектов.
Речь идёт о таких объектах, для которых сложно предусмотреть все необходимые
конструкторы, или создание такого количества конструкторов затруднительно.

Эталон "Строитель" также может быть использован для упрощения процесса 
инициализации объектов классов, в случае, когда для инициализации используется
большое количество параметров, что делает использование конструктора
неудобным.

![Эталон проектирования "Строитель"](https://upload.wikimedia.org/wikipedia/ru/2/28/Builder.gif)

Смысл подхода состоит в том, чтобы описать класс, способный разделить во 
времени моменты инициализации различных атрибутов сложного объекта, либо
разделить весь процесс определения параметров и момент инициализации.

Например, есть класс следующего вида, описывающий представление о человеке, 
которое может быть достаточно сложным:
```java
/**
  * Представление о человеке
  */  
class Person {
    /**
      * Bмя
      */
    private String name;
    /**
      * Фамилия
      */
    private String lastName;
    /**
      * Отчество  
      */
    private String surname;
    /**
      * Дата рождения
      */
    private Date birthDate;
    /**
      * Рост 
      */
    private float height;
    /**
      * Вес
      */
    private float weight;
    
    // ...
}
```
Даже в предложенном варианте получается большое количество конструкторов
для различных вариантов использования описанного класса. Ведь человек
может не иметь отчества или нам может быть не важен вес человека и мы хотим
его опустить при инициализации.

Для выхода из ситуации мы можем использовать эталон проектирования 
"Строитель" и описать в классе `Person` вложенный класс `PersonBuilder`:
```java
/**
  * Представление о человеке
  */
class Person {
    /**
      * "Строитель"
      */
    class PersonBuilder {
        private PersonBuilder() {}
        
        // Объект, инициализация которого выполняется в строителе
        private Person dummy = new Person();
        
        /**
          * Устанавливает имя человека 
          *  
          * @param name имя человека
          * @return ссылку на себя самого, чтобы обеспечить возможность
          * вызова методов по цепочке
          */
        public PersonBuilder name(String name) {
            dummy.name = name;
            return this;
        }
        
        /**
          * Устанавливает фамилию человека 
          *  
          * @param lastName фамилия человека
          * @return ссылку на себя самого, чтобы обеспечить возможность
          * вызова методов по цепочке
          */
        public PersonBuilder lastName(String lastName) {
            dummy.lastName = lastName;
            return this;
        }
        
        // ...
        
        /**
          * Выполняет создание экземпляра класса {@link Person}
          * 
          * @return экземпляр класса {@link Person}
          */
        public Person build() {
            Person result = dummy;
            dummy = new Person();
            return result;
        }
    }
    
    private String name;
    
    private String lastName;
    
    // ...
    
    /**
      * Создаёт "Строитель" класса {@link Person}.
      * 
      * @return экземпляр класса {@link PersonBuilder}.
      */
    public static PersonBuilder builder() {
        return new PersonBuilder();
    }
}
```
Тогда создание экземпляра класса `Person` может быть выполнено следуюшим
образом:
```java
Persin person = Person.builder()
      .name("Иван")
      .lastName("Петров")
      .birthDate(Date.valueOf("01.02.1990"))
      .build(); 
```
Подробнее об эталоне проектирования можно почитать в [Wikipedia](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%BE%D0%B8%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)#Java).

### Эталон проектирования "Фабрика" / Factory

Существует много вариантов реализации данного эталона проектирования. 
Основная идея состоит том, чтобы вынести процесс создания экземпляров
за пределы контекста их использования.

Например, есть некоторый интерфейс:
```java
/**
  * Сервис приложения, отвечающий за аутентификацию и авторизацию 
  * пользователей системы.
  */
public interface UserService {
    /**
      * Выполняет аутентификацию пользователя в системе с использованием
      * переданных учётных данных.
      * 
      * @param credentials учётные дынные пользователя
      * @throws CredentialException если учётные данные были указаны 
      * неполно, или произошла ошибка валидации учётных данных.
      * @throws SecurityException если в системе отсутствует пользователь
      * с указанными учётными данными.
      */
    void signIn(Credentials credentials) throws CredentialException, SecurityException;
    
    /**
      * Завершает пользовательский сеанс.
      * 
      * @param user описатель пользователя системы
      */
    void signOut(User user);
    
    // ...
}
```
У предложенного интерфейса может быть предусмотрено множество 
реализаций, которые мы можем хотеть инкапсулировать на уровне модуля.
Но, при этом, мы хотим предоставить возможность создавать экземпляры
сервиса в контекстах, в которых они могут быть полезны.

Для этих случаев и придуман эталон проектирования "Фабрика". 

В самой простой реализации мы можем создать статический метод, который 
возвращает реализацию обобщая её до описанного интерфейса.
```java
/**
  * Сервис приложения, отвечающий за аутентификацию и авторизацию 
  * пользователей системы.
  */
public interface UserService {
    /**
      * Выполняет аутентификацию пользоателя в сисстеме с использованием
      * переданных учётных данных.
      * 
      * @param credentials учётные дынные пользователя
      * @throws CredentialException если учётные дынне были указаны 
      * неполно, или произошла ошибка валидации учётных данных.
      * @throws SecurityException если в системе отсутствует пользователь
      * с указанными учётными данными.
      */
    void signIn(Credentials credentials) throws CredentialException, SecurityException;
    
    /**
      * Завершает пользовательский сеанс.
      * 
      * @param user описатель пользователя системы
      */
    void signOut(User user);
    
    // ...
    
    /**
      * Абстрактная файрика, возвращющая реализацию серсиса аутентификации
      * и авторизации пользователей.
      * @return экземплр типа {@link UserService}
      */
    static UserService getInstance() {
        return new UserServiceBean();
    }
}
```
С другой стороны нам может требоваться использовать разные реализации, в 
зависимости от того, какие данные нам доступны. Но нам, также, может хотеться
вынести процесс определения того, какая реализация нужна за пределы
контекста её использования.

Примером может послужить конфигурация приложения. Допустим конфигурация
описана следующим интерфейсом:
```java
/**
  * Конфигурация приложения.
  */
public interface Configuration {
    /**
      * Возвращяет имя базы данных.
      * @return имя базы данных в виде строки.
      */
    String getDatabaseName();
    /**
      * Возвращает имя пользователя базы данных, от имени которого
      * будет осуществляться подключение к базе данных.
      * @return имя пользователя в виде строки.
      */
    String getDatabaseUserName();
    /**
      * Возвращает пароль пользователя от имени которого будет 
      * осуществлятся подключение к базе данных.
      * @return пароль в виде строки.
      */
    Stirng getDatabasePassword();
    
    // ...
}
```
Мы можем хотеть в различных ситуациях хранить конфигурацию в различных 
файлах. Например, в виде текстовых файлах, или на специальном сервере, или
в реестре операционной системы. В таком случае мы можем создать несколько
фабричных методов, с одинаковым названием и различными параметрами. Каждый
метод будет возвращать разные реализации, имеющие общий интерфейс.
```java
/**
  * Конфигурация приложения.
  */
public interface Configuration {
    /**
      * Возвращает имя базы данных.
      * @return имя базы данных в виде строки.
      */
    String getDatabaseName();
    /**
      * Возвращает имя пользователя базы данных, от имени которого
      * будет осуществляться подключение к базе данных.
      * @return имя пользователя в виде строки.
      */
    String getDatabaseUserName();
    /**
      * Возвращает пароль пользователя от имени которого будет 
      * осуществляется подключение к базе данных.
      * @return пароль в виде строки.
      */
    Stirng getDatabasePassword();
    
    // ...
    
    /**
      * Возвращает конфигурацию, хранимую в файле.
      * 
      * @param pathname путь к файлу конфигурации
      * @return экземпляр конфигурации.
      */
    static Configuration getInstance(String pathname) {
        return new FileBasedConfiguration(pathname);
    }

    /**
      * Возвращает конфигурацию, хранимую на сервере конфигураций.
      * 
      * @param address адрес сетевого ресурса
      * @return экземпляр конфигурации.
      */
    static Configuration getInstance(SocketAddress address) {
        return new NetworkBasedConfiguration(address);
    }
}
```

## Java Stream API

Поток - представляет собой последовательность элементов, поддерживающая
агрегационные операции над элементами.

> В ближайшее время появится краткая информация о том, как работать с 
потоками.

Подробную информацию можно посмотреть в [официальной документации](https://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html).